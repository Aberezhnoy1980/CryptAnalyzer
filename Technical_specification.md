# Техническое задание

Разработать программу, позволяющую шифровать и расшифровывать текст с использованием шифра Цезаря. Программа должна
поддерживать несколько режимов работы, обеспечивать обработку больших файлов и иметь валидацию входных данных.
Опционально можно добавить графический интерфейс пользователя, а также статистический анализ для автоматического взлома
шифра.

## Основные задачи:

### Реализация шифра Цезаря:

* Создание и использование алфавита.
* Алгоритм сдвига символов в соответствии с заданным ключом.

### Обработка файлов:

* Функциональность для работы с файлами (чтение, запись).
* Обработка больших текстовых файлов.

### Валидация входных данных:

* Проверка существования файлов.
* Допустимость ключей.

## Режимы работы:

Шифрование текста:

* Функция шифрования, принимающая файл, ключ и записывающая зашифрованный текст в новый файл.

Расшифровка текста:

* Функция расшифровки с использованием известного ключа.

Расшифровка методом brute force (опционально):

* Реализация метода brute force для перебора всех ключей до успешного расшифрования.

Расшифровка методом статистического анализа (опционально):

* Разработка алгоритма статистического анализа для автоматической расшифровки без ключа, используя особенности языка.

Разработка интерфейса пользователя:

* Текстовое меню или (опционально) графический интерфейс

### Дополнительные задачи:

* Обработка ошибок и исключений.
* Оптимизация для производительности.
* Документация и тестирование.

## Результат

Результат: программа работает в нескольких режимах

### Режимы:

* Шифровка текста
* Расшифровка текста с помощью ключа
* Расшифровка текста с помощью brute force (перебор всех вариантов)
* (дополнительно) Расшифровка с помощью статистического анализа текста

Программа должна открывать указанный пользователем файл с текстом и проделывать с ним одно из указанных выше действий.
После этого создавать новый файл с результатом.

Программа должна выполнять следующие функции:

* Шифровка текста из заданного файла. На вход она получает адрес файла с оригинальным текстом, адрес файла в который
  нужно записать зашифрованный текст, и сдвиг по алфавиту (это является ключом шифра Цезаря). Не забудь проделать
  проверку
  того что а) файл оригинала по заданному адресу существует, и б) ключ от 0 и до (размер алфавита - 1) (или можете взять
  остаток от деления на размер алфавита).
* Расшифровка при известном ключе. На входе — адрес зашифрованного файла и адрес куда писать расшифрованный файл, а
  также сдвиг по алфавиту который использовался при шифровании (ключ).
* Расшифровка методом brute force (перебором всех возможных сдвигов); На входе - адрес зашифрованного файла, (
  опционально)
  адрес файла с текстом который является примером текста что был зашифрован (например другой труд того же автора) и
  адрес
  файла который должен содержать расшифрованный текст.
* Расшифровка методом статистического анализа; На входе тоже самое что и для расшифровки перебором.

Не забудь проделать валидацию входных данных.

Исходный текст для шифрования должен быть в файле. Желательно в формате txt. программа должна уметь работать с большими
текстами на сотни страниц. Этот файл программа должна уметь зашифровать и записать зашифрованный текст в другой файл.

## Рекомендации/подсказки

### Алфавит

Создай алфавит, в котором существует задача. По условию это русский алфавит и пунктуация . , ” ’ : - ! ? ПРОБЕЛ
Не забываем про пробел! Как это можно сделать? Например, можно загнать алфавит в String, несколько строк или массив
String.

Или… можно создать алфавит на основе множества Set, массива или списка List. А ещё можно воспользоваться таблицей ASCII.

Помни, что алфавит не меняется, поэтому такую переменную логично сделать константой public static final.
Имя таких переменных принято писать заглавными буквами.

```java
private static final List ALPHABET = Arrays.asList('а', 'б',
        'в', 'г', 'д', 'е', 'ж', 'з', 'и', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у',
        'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'я', '.', ',', '«', '»',
        ':', '!', '?', ' ');
```

А еще лучше применить обычный массив (так как алфавит не меняется, нет никакого смысла засовывать его в список).
Массивы занимают меньше памяти, и поэтому, по возможности, надо использовать именно массивы, особенно если речь идет
о примитивных типах (в списках примитивные типа оборачиваются в объекты и занимают значительно больше памяти).

```java
private static final char[] ALPHABET = {'а', 'б', 'в', 'г', 'д', 'е', 'ж', 'з',
        'и', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ',
        'ъ', 'ы', 'ь', 'э', 'я', '.', ',', '«', '»', '"', '\'', ':', '!', '?', ' '};
```

### Шифровка

Для нее нужно знать сдвиг (ключ) и алфавит.

Для каждого символа оригинального текста нужно:

* проверить что он есть в вашем алфавите. Если его нет, пропускаем этот символ.
* найти его позицию в алфавите. Подумай, какую структуру данных нужно использовать чтобы ускорить этот процесс (раз в
  15),
  ведь необязательно же сканировать всю библиотеку в поисках книги на букву Ы (Ладно, П).
* найти символ на позиции смещенной на заданный сдвиг. И помним что в примере с игрушкой Y стала А (и не улетела в
  космос).
  Как это гарантировать? (можно сделать (позиция буквы + сдвиг) %( размер алфавита). Процент - оператор получения
  остатка от деления).
* заменить оригинальный символ на зашифрованный

Сохранить результат в файл (чтобы избежать плохого пользователя который попробует зафигачить тебе .bash_profile или
hosts
валидируй имя файла вывода!)

### Создать интерфейс программы / меню пользователя

Графический интерфейс можно создать с помощью JavaFX или Swing. Желательно этим заморочиться уже после создания основной
программы. Однако если не успеваешь или не хочешь тратить на это время, можно создать простое текстовое меню и вывести
его в консоль. Например:

```java
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.Parameters;
import picocli.CommandLine.Option;
import picocli.CommandLine.ParameterException;
import picocli.CommandLine.Spec;

import java.util.Locale;
import java.io.File;

@Command(name = "cypher", subcommands =
        {CommandLine.HelpCommand.class},
        description = "Caesar cypher command")
public class Cypher implements Runnable {
    @Spec
    CommandSpec spec;
    @Command(name = "encrypt", description = "Encrypt from
    file to
    file using
    key")

    void encrypt(
            @Parameters(paramLabel = "", description =
                    "source file with text to encrypt") File src,
            @Parameters(paramLabel = "", description =
                    "dest file which should have encrypted text") File dest,
            @Parameters(paramLabel = "", description =
                    "key for encryption") int key) {
        // TODO
    }

    @Command(name = "brute force", description = "Decrypt
    from file
    to file
    using brute
    force") // |3|

    void bruteForce(
            @Parameters(paramLabel = "", description =
                    "source file with encrypted text") File src,
            @Option(names = {"-r",
                    "--representative"}, description = "file with unencrypted
            representative text") File representativeFile,
                    @Parameters(paramLabel = "", description =
                            "dest file which should have decrypted text") File dest) {
        // TODO
    }

    @Command(name = "statistical decryption", description =
            "Decrypt from file to file using statistical analysis")
        // |3|
    void statisticalDecrypt(
            @Parameters(paramLabel = "", description =
                    "source file with encrypted text") File src,
            @Option(names = {"-r",
                    "--representative"}, description = "file with unencrypted
            representative text") File representativeFile,
                    @Parameters(paramLabel = "", description =
                            "dest file which should have decrypted text") File dest) {
        // TODO
    }

    @Command(name = "decrypt", description = "Decrypt from
    file to
    file using
    statistical analysis") // |3|

    void decrypt(
            @Parameters(paramLabel = "", description =
                    "source file with encrypted text") File src,
            @Parameters(paramLabel = "", description =
                    "dest file which should have decrypted text") File dest,
            @Parameters(paramLabel = "", description =
                    "key for encryption") int key) {
        // TODO
    }

    @Override
    public void run() {
        throw new ParameterException(spec.commandLine(),
                "Specify a subcommand");
    }

    public static void main(String[] args) {
        int exitCode = new CommandLine(new
                Cypher()).execute(args);
        System.exit(exitCode);
    }
}
```

Если не хочешь разбираться с библиотекой Picocli, можешь поступить максимально просто: сделать меню с помощью циклов или
оператора switch. Также нужно, чтобы программа завершала работу по желанию пользователя (например, вводом слова “exit”).

### Работа с файлами

Для работы с файлами рекомендуется использовать библиотеку Java NIO, так как:

* Это более современный и производительный API по сравнению с IO.
* Поддерживает асинхронную обработку файлов.
* Обеспечивает корректную работу с большими файлами.

Основные классы NIO для работы с файлами:

`Path:` Представляет путь к файлу или директории.

`Files:` Предоставляет статические методы для работы с файлами и директориями (чтение, запись, копирование, удаление и
т.д.).

`Charset:` Представляет кодировку символов, используемую при чтении/записи текстовых файлов.

Пример чтения большого файла с помощью NIO:

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;

public class FileHandler {

    public static String readFile(String filePath) throws IOException {
        Path path = Paths.get(filePath);
        byte[] bytes = Files.readAllBytes(path);
        return new String(bytes, StandardCharsets.UTF_8);
    }

    // ... другие методы для работы с файлами ...

}
```

**Рекомендации для работы с большими файлами:**

* Чтение/запись по частям. Для очень больших файлов, которые не помещаются в оперативную память, используйте методы
  Files.lines() для чтения по строкам или Files.newInputStream() для чтения по блокам.
* Буферизация. Используй BufferedReader и BufferedWriter для буферизации операций ввода/вывода, что повышает
  производительность.

### Расшифровка

Для нее нужно знать сдвиг (ключ) и алфавит.

Для каждого символа зашифрованного текста нужно:

* проверить что он есть в твоем алфавите. Если нет — тебя ломают хакеры. Паникуй (ну, или верни ошибку).
* найти его позицию в алфавите.
* найти символ на позиции смещенной на заданный сдвиг (но только помни: ты не пытаешься еще раз зашифровать шифр,
  поэтому сдвигаем в другую сторону).
* заменить зашифрованный символ на расшифрованный

Ты будешь использовать этот код использовать в следующих подзадачах, поэтому выводить результат можно в поток.

Сохранить результат нужно в файл.

### Взлом (Brute Force)

Ты можешь использовать код который написал для расшифровки при известном ключе, подставляя все возможные значения ключа.

Но как понять получилось ли расшифровать? Используй пример текста (репрезентативный текст автора или в том же стиле).
Можно составить словарь слов и составить метрику основанную на том, сколько слов совпало и какой они длины; или иную
метрику которая изучает длину слов и предложений, или посмотреть какие буквы чаще всего предшествуют каким буквам или
словарь наиболее частых начал слова (3 буквы), можно вообще не использовать никаких репрезентативных файлов и проверить
правильность пунктуации и пробелов; Вариант с наилучшими результатами сохрани в файл вывода.

### Взлом (Статистический анализ)

Дополнительное требования(опционально)

Используй пример текста (репрезентативный текст автора или в том же стиле) и составь статистику букв (например,
как часто встречается на каждые 1000 символов). Кстати. Легко взломать шифр и без такого файла и анализа: попробуйте
угадать пробел — это наверняка наиболее часто встречающийся символ в обычном тексте.

Далее составь такую же статистику для зашифрованного текста. Учти, просто считать символы не достаточно так как тексты
могут быть разной длины!

Далее посчитай отклонение для каждого возможного сдвига зашифрованной статистики относительно репрезентативной (можно
для этого использовать сумму квадратов отклонения или дот-произведение векторов). Найди сдвиг, дающий минимальное
отклонение и расшифруйте используя этот сдвиг.